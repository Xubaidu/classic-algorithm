# 欧拉路径

## 概念

复习一下离散数学，用 ```ind[i], outd[i]``` 表示点 ```i``` 的入度和出度

- 如果一个图的每一个点都满足 ```ind[i] = outd[i]```，即度数为偶数，那么这个图就是一个欧拉图，可以一笔画走成一条环路

- 如果一个图有一个点满足 ```ind[i] = outd[i] + 1```，一个点满足 ```ind[i] + 1 = outd[i]```，剩下的点满足 ```ind[i] = outd[i]```，那么这个图就是一个半欧拉图，可以在访问每一个边仅一次的前提下遍历图

## 算法

对于欧拉图的 ```dfs```，假设起点为 ```u```，步骤如下

- 递归，遍历到下一个节点 ```v```，删除 ```u->v``` 的边
- 回溯，如果 ```u``` 无路可走，将 ```u``` 放入栈

欧拉图的特性保证

- 半欧拉图的「死胡同」仅会出现在终点
- 如果当前点 ```u``` 可以走到死胡同 ```v```，那么 ```v``` 一定先于 ```u``` 的其他出点先入栈

最后逆序输出栈即可，由于只涉及到图遍历，因此时间复杂度为 $\mathcal{O}(n)$

## 代码实现

```cpp
// cpp17
// dfs 遍历图寻找欧拉路径
void dfs(int u, unordered_map<int, vector<int>>& g, vector<vector<int>>& ans)
{
    auto& vec = g[u];
    while (vec.size()) {
        int v = vec.back();  // 找到下一个点 v
        vec.pop_back();  // 删边
        dfs(v, g, ans);  // 递归
        ans.push_back(vector<int>{u, v});  // 回溯，用栈维护
    }
}

// findPath 寻找起点调用 dfs 函数
vector<vector<int>> findPath(unordered_map<int, int>& deg, unordered_map<int, vector<int>>& g)
{
    int pos = -1;
    for (auto& [x, y]: deg) {
        if (y == -1) pos = x;  // 找到起点，也就是 indegree = outdegree - 1 的点
    }
    if (pos == -1) pos = deg.begin()->first;
    vector<vector<int>> ans;
    dfs(pos, g, ans);
    reverse(ans.begin(), ans.end());
    return ans;
}
```