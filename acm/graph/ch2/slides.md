---
marp: true
theme: gaia
paginate: true
math: katex
---

# 图论讲义 $2$

- 拓扑排序
- 有向无环图
- 习题选讲

---

## 拓扑排序

拓扑排序是一种对图的排序方式，用来挖掘图节点之间的依赖关系。

对于任意两个节点 $u,\ v$，如果存在边 $u\rightarrow v$，那么经过拓扑排序之后，$u$ 一定在 $v$ 前面。

---

## 排序前 VS 排序后

![w:200px, h:400px](./pic/topo_sort.png)

---

## 应用场景

我们在上课之前需要学一些基础课程，例如在上物理课之前需要学习数学课，这便是一个典型的依赖关系。

老师在安排课表的时候，可以根据多个这样的先修课关系建立图论模型，然后使用拓扑排序得到一个合理的上课顺序。

但是，如果老师在排课表的时候发现存在双向依赖，他就无法进行拓扑排序了，这是因为拓扑排序无法处理有环的场景。

---

## 拓扑排序的能力

抽象的来说，拓扑排序有两个能力

- 将无环图简化成一个有向无环图
- 检测图中是否存在环路

从经验上来讲，拓扑排序往往是一个前序工作，对图信息做一定的挖掘，来服务后面的算法，例如动态规划等等。

---

## Kahn 算法

拓扑排序的算法为 Kahn，类似于 bfs，步骤如下

- 建图，计算所有点的入度，同时将入度为 $0$ 的点放入队列。
- 取出队首，将它所有的出点入度减少 $1$，如果有出点的入度降为 $0$，放入队列。
- 重复上述操作，直到队列为空。

---

## Kahn 算法

算法结束后，有两种情况
- 无环图，任意点的入度都将降低为 $0$
- 有环图，一定存在一对点，它们的入度不为 $0$

如果想要检测是否有环，只需要判断是否存在入度不为 $0$ 的点即可。

分析一下时间复杂度，每个点和边都被访问了 $\mathcal{O}(1)$ 次，因此为 $\mathcal{O}(n + m)$，其中 $n$ 为节点的个数，$m$ 为边的数量。

---

## 核心代码

```cpp
queue<int> q;
for (int i = 1; i <= n; ++i) if (!ind[i]) q.push(i);
while (!q.empty()) {
    int temp = q.front(); q.pop();
    ans[++cnt] = temp;
    for (int i = 0; i < g[temp].size(); ++i) {
        int v = g[temp][i];
        ind[v]--;
        if (!ind[v]) q.push(v);
    }
}
```

---

## 字典序最小的拓扑序

往往拓扑序是不唯一的，如果想要计算字典序最小的拓扑序，只需要用优先队列代替队列维护入度为 $0$ 的点即可。

分析一下时间复杂度，每个点和边都被访问了  $\mathcal{O}(1)$ 次，并且用优先队列来维护点集，所以为 $\mathcal{O}(m + n\log n)$，其中 $n$ 为节点的个数，$m$ 为边的数量。

---

## 有向无环图

有向无环图（Directed Acyclic Graph, DAG）是能够表征依赖关系的图结构。

如果一个图可以进行拓扑排序，那么它一定是 DAG，反之，一个 DAG 也一定可以被拓扑排序。所以，想要检测一个图是否是 DAG，只需要对其进行拓扑排序即可。

值得一提的是，所有的动态规划的状态转移都可以归类为 DAG 上的转移，这是由 DAG 点之间的依赖关系决定的。

---

## 877. 解锁关卡

有 $n$ 个关卡需要通关，但是有 $m$ 条依赖关系，第 $i$ 条为：解锁关卡 $a_i$ 前必须先解锁关卡 $b_i$。

请你为 $n$ 个关卡设置一个合理的通关顺序。若有多解，请输出字典序最小的解。

数据规定 $n\leq 1000,\ m\leq 10000,\ 1\leq a_i,\ b_i\leq n$

---

## 题解

输出字典序最小的拓扑序。

建图后用 Kahn 算法，并用优先队列维护入度为 $0$ 的点集。

时间复杂度为 $\mathcal{O}(m + n\log n)$。